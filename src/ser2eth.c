/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Introduction
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************//**
 * @file      ser2eth.c
 * 
 * @version   1.0
 *
 * @date      27-04-2025
 *
 * @brief     Captures information from the serial port specified by the -s argument.
 *            Decodes the captured information and sends it to the interface specified by the -i argument.
 *  
 * @author    Fábio D. Pacheco, 
 * @email     fabio.d.pacheco@inesctec.pt or pacheco.castro.fabio@gmail.com
 *
 * @copyright Copyright (c) [2025] [Fábio D. Pacheco]
 * 
 * @note      
 * 
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Imported libraries
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <argp.h>
#include <errno.h>
#include <sys/mman.h>
#include <cobs.h>
#include <libserialposix.h>
#include <rawsoc.h>
#include <semaphore.h>
#include <shmbuf.h>
#include <time.h>
#include <mixip.h>

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Data structures
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

struct arguments{
  char * name;                         // Instance name
  char * interface;                    // Network interaface file descriptor
};

typedef struct{
  uint8_t sr_segme:1;                  // Inside a Serial port Segment (SS)  
  uint8_t sr_first:1;                  // First byte of the SS
  uint8_t et_frame:1;                  // Inside a Ethernet Frame (EF)
  uint8_t et_first:1;                  // First byte of the EF
  uint8_t et_drop:1;                   // Reminds the program to drop the frame 
  uint8_t error:1;                     // Close the program because of a major error
} flag_t ;

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Prototypes
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

static error_t parseArgs( int key, char * arg, struct argp_state *state );

int8_t find_segm( const buffer_t * src, buffer_t * dst, flag_t * flag, const uint8_t delimiter, size_t * index );
int8_t decode_sr( buffer_t * src, const uint8_t overhead );
int8_t find_frame( const buffer_t * src, buffer_t * dst, flag_t * flag, const uint8_t delimiter );
int8_t decode_et( buffer_t * src, buffer_t * dst );

void cleanup( buffer_t * buf );

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Global variables
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

const char  * argp_program_version     = "ser2eth 1.0";
const char  * argp_program_bug_address = "fabio.d.pacheco@inesctec.pt";
static char   doc[ ]                   = "Serial to Ethernet, is a program that captures and decodes information from the serial port and sends to the network interface.";
static char   args_doc[ ]              = "Instance-Name Network-Interface-FileDescriptor";

static struct argp_option options[ ] = {
  {"name",      'n', "<instance-name>" , 0, "The instance name"                           , 0 },
  {"interface", 'i', "<interface>"     , 0, "A file descriptor for the network interface" , 0 },
  { 0 }
};
 
static struct argp argp = { options, parseArgs, args_doc, doc, NULL, NULL, NULL };

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Functions
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
static error_t
parseArgs( int key, char * arg, struct argp_state * state ){
  struct arguments * arguments = state->input;
  switch( key ){
    case 'n':
      arguments->name = arg;
      break;

    case 'i':
      arguments->interface = arg;
      break;

    case ARGP_KEY_ARG:
      // Index of each extra argument not specified by an option key
      break;
 
    case ARGP_KEY_END:
      // Number of extra arguments not specified by an option key
      if( 0 != state->arg_num )
        argp_usage( state );
      break;

    default:
      return ARGP_ERR_UNKNOWN;
  }
  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
int8_t
find_segm( const buffer_t * src, buffer_t * dst, flag_t * flag, const uint8_t delimiter, size_t * index ){
  if( !src || !dst || !flag || !index ){
    errno = EINVAL;
    return -1;
  }

  for( size_t i = 0 ; i < src->len ; ++i ){
    if( !flag->sr_segme && delimiter == src->data[ i ] ){
      flag->sr_segme = 1;
      flag->sr_first = 1;
      dst->len = 0;
    }

    if( flag->sr_segme ){
      if( sizeof( dst->data ) <= dst->len ){
        flag->sr_segme = 0;
        dst->len = 0;
      }

      else{
        dst->data[ dst->len ++ ] = src->data[ i ];

        if( delimiter == src->data[ i ] ){
          //   _ SS EOF Limiter
          //  /    _ SS SOF Limiter
          //  |   /
          if( 1 + 1 == dst->len ){
            flag->sr_first = 1;
            dst->len = 1;
          }

          if( flag->sr_first )
            flag->sr_first = 0;

          else{
            *index = i;
            flag->sr_segme = 0;
            return 1;
          }

        }

      }

    }

  }

  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
int8_t 
decode_sr( buffer_t * src, const uint8_t overhead ){
  if( !src ){
    errno = EINVAL;
    return -1;
  }

  cobs_ret_t result = cobs_decode_tinyframe( &src->data[ 1 ], src->len - 1 );
  //                                    SS SOF Limiter__/

  if( COBS_RET_SUCCESS == result ){
    src->len -= overhead;
    memmove( src->data, &src->data[ overhead - 1 ], src->len );                        
    return 1;
  }

  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
int8_t 
find_frame( const buffer_t * src, buffer_t * dst, flag_t * flag, const uint8_t delimiter ){
  if( !src || !dst || !flag ){
    errno = EINVAL;
    return -1;
  }
  
  flag->et_drop = 0;

  for( size_t i = 0 ; i < src->len ; ++i ){
    if( !flag->et_frame ){
      if( delimiter != src->data[ i ] ){
        flag->et_drop = 1;
        break;
      }
      
      flag->et_frame = 1;
      flag->et_first = 1;
      dst->len = 0;
    }
    
    if( sizeof(dst->data) <= dst->len ){
      flag->et_drop = 1;
      break;
    }

    dst->data[ dst->len ++ ] = src->data[ i ];

    if( flag->et_first )
      flag->et_first = 0;

    else if( delimiter == src->data[ i ] )
      return 1;
  }
  
  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
int8_t 
decode_et( buffer_t * src, buffer_t * dst ){
  if( !src || !dst ){
    errno = EINVAL;
    return -1;
  }
   
  //                                            _ EF SOF limiter
  //                                           /
  cobs_ret_t result = cobs_decode( &src->data[ 1 ], 
                                    src->len - 1, 
                                    dst->data, 
                                    sizeof( dst->data ), 
                                    &dst->len );

  if( COBS_RET_SUCCESS == result )
    return 1;
  
  return 0;
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
void 
cleanup( buffer_t * buf ){
  if( NULL != buf ) shm_close2( NULL, buf, sizeof(buffer_t) );
}

/**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
void
printPacket( const uint8_t * pk, const size_t len, const char * cover, int columnsize ){
  if( !pk ) return;

  time_t t;
  struct tm * info;
  time( &t );
  info = localtime( &t );
  char tm[12]; strftime( tm, sizeof(tm), "%H:%M:%S", info );

  int cont = columnsize;
  printf("<-----%s Packet [%s]----->\n", cover, tm );
  for( size_t i = 0 ; i < len ; ++i ){
    if( !cont || (i + 1 == len) ){
      printf( "%04ld:%02X\n", i, pk[i] );
      cont = columnsize;
    }
    else {
      printf( "%04ld:%02X ", i, pk[i] );
      cont--;
    }
  }
  printf("<-----%s Packet----->\n\n", cover);
}

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * Main function
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/

int
main( int argc, char **argv ){
  struct arguments arguments = { .name = "", .interface = "" };
  argp_parse( &argp, argc, argv, 0, 0, &arguments );
  
  // Check the parameters
  if( !strcmp( arguments.name, "" ) || !strcmp( arguments.interface, "" ) ){
    errno = EINVAL;
    perror("missing arguments");
    return EXIT_FAILURE;
  }

  // Shared memory definitions
  char path[ 128 ];
  snprintf( path, sizeof(path), "/%s_rx", arguments.name );
  //                                                          __ Inherit the creator permissions
  //                                                         /
  buffer_t * serial = shm_open2( path, sizeof(buffer_t), O_RDWR, 0 );
  if( !serial ){
    perror("shm_open2");
    return EXIT_FAILURE;
  }
 
  // Connect to the interface
  int nic = atoi( arguments.interface );
  if( !nic ){
    perror("atoi");
    cleanup( serial );
    return EXIT_FAILURE;
  }

  flag_t flag = {0};
  int8_t result;

  buffer_t chunk;
  buffer_t segment;
  buffer_t frame;

  const uint8_t  limiter  = 0x00;
  
  const uint8_t  overhead = 1 + 1 + 2;
  //                Limiter_/   /   \_COBS
  //                    Window_/ 

  printf("[%d] Read from serial port and convert to ethernet process...\n", getpid( ) );
  for( ; ; ){
    sem_wait( &serial->available );
    memcpy( chunk.data, serial->data, serial->len );
    chunk.len = serial->len;

    size_t index = 0;
    while( 0 < (result = find_segm( &chunk, &segment, &flag, limiter, &index ) ) ){
      if( -1 == result )
        break;

      if( 0 < chunk.len - index + 1 ){
        memmove( chunk.data, &chunk.data[ index + 1 ], chunk.len - index + 1 );
        chunk.len -= index + 1;
      }

      if( (result = decode_sr( &segment, overhead )) ){
        if( 0 < (result = find_frame( &segment, &frame, &flag, limiter )) ){  
          flag.et_drop = 1;
          buffer_t decoded;
    
          if( (result = decode_et( &frame, &decoded )) )
            write( nic, decoded.data, decoded.len );
        }
        else{
          if( -1 == result )
            break;
        }
      }
      else{
        if( -1 == result )
          perror("decode_sr");
        printf("Serial Segment decoding error...\n");
        flag.et_drop = 1;        
      }

      if( flag.et_drop ){
        flag.et_drop = 0;
        flag.et_frame = 0;
        frame.len = 0;
      }

    }
      
    if( -1 == result ){
      perror("algorithm");
      cleanup( serial );
      return EXIT_FAILURE;
    }

    sem_post( &serial->empty );    
  }

}

/***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
 * End file
 **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
